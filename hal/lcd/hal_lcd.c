#define _HAL_LCD_C_

#include "syntax.h"

#include "stm32f10x.h"

#include "hal_pincfg.h"
#include "hal_lcd.h"

#include "debug.h"

static GPIO_TypeDef *const dataport = GPIOB;
static GPIO_TypeDef *const ctrlport = GPIOC;

static const uint data0_pin_idx = 2;
static const uint data1_pin_idx = 3;
static const uint data2_pin_idx = 4;
static const uint data3_pin_idx = 5;

static const uint data4_pin_idx = 12;
static const uint data5_pin_idx = 13;
static const uint data6_pin_idx = 14;
static const uint data7_pin_idx = 15;

static const uint wr_pin_idx = 6;
static const uint rd_pin_idx = 7;
static const uint ce_pin_idx = 8;
static const uint cd_pin_idx = 9;

static ldc_rt_t rt;

// symbol code to lcd character generator code
static const u8 remap_lut[256] =
{
    [' '] = 0x00, ['!'] = 0x01, ['"'] = 0x02, ['#'] = 0x03, ['$'] = 0x04, ['%'] = 0x05, ['&'] = 0x06, ['\''] = 0x07,
    ['('] = 0x08, [')'] = 0x09, ['*'] = 0x0A, ['+'] = 0x0B, [','] = 0x0C, ['-'] = 0x0D, ['.'] = 0x0E, ['/'] = 0x0F,
    ['0'] = 0x10, ['1'] = 0x11, ['2'] = 0x12, ['3'] = 0x13, ['4'] = 0x14, ['5'] = 0x15, ['6'] = 0x16, ['7'] = 0x17,
    ['8'] = 0x18, ['9'] = 0x19, [':'] = 0x1A, [';'] = 0x1B, ['<'] = 0x1C, ['='] = 0x1D, ['>'] = 0x1E, ['?'] = 0x1F,
    ['@'] = 0x20, ['A'] = 0x21, ['B'] = 0x22, ['C'] = 0x23, ['D'] = 0x24, ['E'] = 0x25, ['F'] = 0x26, ['G'] = 0x27,
    ['H'] = 0x28, ['I'] = 0x29, ['J'] = 0x2A, ['K'] = 0x2B, ['L'] = 0x2C, ['M'] = 0x2D, ['N'] = 0x2E, ['O'] = 0x2F,
    ['P'] = 0x30, ['Q'] = 0x31, ['R'] = 0x32, ['S'] = 0x33, ['T'] = 0x34, ['U'] = 0x35, ['V'] = 0x36, ['W'] = 0x37,
    ['X'] = 0x38, ['Y'] = 0x39, ['Z'] = 0x3A, ['['] = 0x3B, ['\\'] = 0x3C, [']'] = 0x3D, ['^'] = 0x3E, ['_'] = 0x3F,
    ['`'] = 0x40, ['a'] = 0x41, ['b'] = 0x42, ['c'] = 0x43, ['d'] = 0x44, ['e'] = 0x45, ['f'] = 0x46, ['g'] = 0x47,
    ['h'] = 0x48, ['i'] = 0x49, ['j'] = 0x4A, ['k'] = 0x4B, ['l'] = 0x4C, ['m'] = 0x4D, ['n'] = 0x4E, ['o'] = 0x4F,
    ['p'] = 0x50, ['q'] = 0x51, ['r'] = 0x52, ['s'] = 0x53, ['t'] = 0x54, ['u'] = 0x55, ['v'] = 0x56, ['w'] = 0x57,
    ['x'] = 0x58, ['y'] = 0x59, ['z'] = 0x5A, ['{'] = 0x5B, ['|'] = 0x5C, ['}'] = 0x5D, ['~'] = 0x5E,
};

// NOTE: default pin state is: command, no chip enable, no read, no write, databus is output

static inline int assert_ce(void)               { ctrlport->BRR = (1 << ce_pin_idx); return 1;}
static inline void deassert_ce(int *dummy)      { ctrlport->BSRR = (1 << ce_pin_idx); }

static inline void assert_wr(void)              { ctrlport->BRR = 1 << wr_pin_idx;}
static inline void deassert_wr(void)            { ctrlport->BSRR = 1 << wr_pin_idx;}
static inline void assert_rd(void)              { ctrlport->BRR = 1 << rd_pin_idx;}
static inline void deassert_rd(void)            { ctrlport->BSRR = 1 << rd_pin_idx;}
static inline void assert_data_mode(void)       { ctrlport->BRR = 1 << cd_pin_idx;}
static inline void deassert_data_mode(void)     { ctrlport->BSRR = 1 << cd_pin_idx;}

#define LCD_XFER for (int _todo __cleanup(deassert_ce) = assert_ce(); _todo; _todo = 0)

static inline void wait_50ns(void)
{
    __NOP();
    __NOP();
}

// high-z
static void switch_to_input(void)
{
    dataport->CRL = (dataport->CRL & 0xFF0000FF) | 0x00444400;
    dataport->CRH = (dataport->CRH & 0x0000FFFF) | 0x44440000;
}

// push-pull, 50 MHz
static void switch_to_output(void)
{
    dataport->CRL = (dataport->CRL & 0xFF0000FF) | 0x00333300;
    dataport->CRH = (dataport->CRH & 0x0000FFFF) | 0x33330000;
}

// generated by http://programming.sirrida.de/calcperm.php
static void drive_data(uint data)
{
    uint to_set = data;
    uint to_clear = ~data;

    dataport->BSRR =   ((to_set & 0x0F) << 2) | ((to_set & 0xF0) << 8)
                     | ((to_clear & 0x0F) << 18) | ((to_clear & 0xF0) << 24);
}

static uint sample_data(void)
{
    uint reg = dataport->IDR;
    return ((reg & 0x0000F000) >> 8) | ((reg & 0x0000003C) >> 2);
}

// keep it simple for now
static void write_cmd(uint cmd)
{
    drive_data(cmd);

    assert_wr();
    wait_50ns();
    wait_50ns();
    deassert_wr();
    wait_50ns();
}

static void write_data(uint data)
{
    drive_data(data);

    assert_data_mode();
    wait_50ns();
    assert_wr();
    wait_50ns();
    wait_50ns();
    deassert_wr();
    wait_50ns();
    deassert_data_mode();
}


static bool verify_status(uint val, uint mask)
{
    bool is_ok = 0;

    switch_to_input();

    assert_rd();
    wait_50ns();
    wait_50ns();
    wait_50ns();

    uint result;
    uint tries = STATUS_CHECK_N_TRIES;
    do
    {
        result = sample_data();
        if ((result & mask) == val)
        {
            is_ok = 1;
            break;
        }
    } while (--tries);

    deassert_rd();
    wait_50ns();

    switch_to_output();

    if (! is_ok)
        WARN("failed to verify lcd status %d %d %d", result,  val, mask);

    return is_ok;
}



static bool exec_cmd(uint cmd, const void *data, uint len)
{
    const u8 *p = data;
    for (; len; len--)
    {
        if (! verify_status(3, 3))
            return 0;
        write_data(*p++);
    }

    if (! verify_status(3, 3))
        return 0;

    write_cmd(cmd);
    return 1;
}


static bool write_mem(uint addr, const void *data, uint len)
{
    if (! exec_cmd(SET_ADDRRESS_POINTER, &addr, 2))
        return 0;

    if (! exec_cmd(SET_DATA_AUTO_WRITE, NULL, 0))
        return 0;

    const u8 *p = data;
    while (len--)
    {
        if (! verify_status(8, 8))
            return 0;
        write_data(*p++);
    }

    if (! exec_cmd(AUTO_RESET, NULL, 0))
        return 0;

    return 1;
}


static bool write_mem_from_generator(uint addr, int (*gen)(void))
{
    if (! exec_cmd(SET_ADDRRESS_POINTER, &addr, 2))
        return 0;

    if (! exec_cmd(SET_DATA_AUTO_WRITE, NULL, 0))
        return 0;

    int val;
    while ((val = gen()) >= 0)
    {
        if (! verify_status(8, 8))
            return 0;
        write_data(val);
    }

    if (! exec_cmd(AUTO_RESET, NULL, 0))
        return 0;

    return 1;
}


static bool update_display_mode(void)
{
    uint mode;
    if (! (rt.flags & F_LCD_IS_ON))
    {
        mode = F_DISPLAY_MODE_OFF;
    }
    else
    {
        if (rt.flags & F_LCD_IS_GRAPHIC)
        {
            mode = F_DISPLAY_MODE_TEXT_OFF_GRAPHIC_ON;
        }
        else
        {
            mode = F_DISPLAY_MODE_TEXT_ON_GRAPHIC_OFF;
            if (rt.flags & F_LCD_CURSOR_IS_DISPLAYED)
            {
                if (rt.flags & F_LCD_CURSOR_IS_BLINKING)
                    mode |= F_DISPLAY_MODE_CURSOR_ON_BLINK_ON;
                else
                    mode |= F_DISPLAY_MODE_CURSOR_ON_BLINK_OFF;
            }

        }
    }

    if (! exec_cmd(SET_DISPLAY_MODE_PREFIX | mode, NULL, 0))
        return 0;

    return 1;
}


static bool configure(void)
{
    rt.flags &= ~F_LCD_IS_ON;

    LCD_XFER
    {
        if (! update_display_mode())
            return 0;

        uint data;
        data = GRAPHIC_PAGE_ADDR;
        if (! exec_cmd(SET_GRAPHIC_HOME_ADDRESS, &data, 2)) return 0;

        data = TEXT_PAGE_ADDR;
        if (! exec_cmd(SET_TEXT_HOME_ADDRESS, &data, 2)) return 0;

        PANIC_IF(CG_BASE_ADDR % 0x800);
        data = CG_BASE_ADDR / 0x800;
        if (! exec_cmd(SET_OFFSET_REGISTER, &data, 2)) return 0;

        data = HAL_LCD_NCOLS;
        if (! exec_cmd(SET_GRAPHIC_AREA, &data, 2)) return 0;
        if (! exec_cmd(SET_TEXT_AREA, &data, 2)) return 0;

        if (! exec_cmd(SET_MODE_PREFIX | F_MODE_EXOR, NULL, 0)) return 0;

        int gen_idx;
        int ram_cleaner(void)
        {
            if (gen_idx++ < LCD_RAM_SIZE)
                return 0;
            return -1;
        }

        int cg_loader(void)
        {
            extern const uchar ExtCG[];
            if (gen_idx < 96 * 8)
                return (ExtCG[gen_idx++] - 0x20) & 0x3F;
            return -1;
        }

        gen_idx = 0;
        if (! write_mem_from_generator(0, ram_cleaner)) return 0;

        gen_idx = 0;
        if (! write_mem_from_generator(CG_BASE_ADDR + 128 * 8, cg_loader)) return 0;
    }

    return 1;
}


// TODO: add some rollback in case of errors ? Now we just fail
bool HAL_lcd_render_text(const hal_lcd_text_buf_t *buf)
{
    LCD_XFER
    {
        if (! write_mem(TEXT_PAGE_ADDR, buf->raw, sizeof(buf->raw)))
            return 0;

        rt.flags &= ~F_LCD_IS_GRAPHIC;
        rt.flags |= F_LCD_IS_ON;
        if (! update_display_mode())
            return 0;
    }

    return 1;
}


bool HAL_lcd_render_ugly_encoded_text(const hal_lcd_text_buf_t *buf)
{
    uint gen_idx;

    int text_sender(void)
    {
        if (gen_idx >= countof(buf->raw))
            return -1;

        //int result = remap_lut[buf->raw[gen_idx]];
        int result = buf->raw[gen_idx] - 0x20;

        gen_idx++;

        return result < 0 ? 0 : result;
    }

    gen_idx = 0;
    LCD_XFER
    {
        if (! write_mem_from_generator(TEXT_PAGE_ADDR, text_sender))
            return 0;

        rt.flags &= ~F_LCD_IS_GRAPHIC;
        rt.flags |= F_LCD_IS_ON;
        if (! update_display_mode())
            return 0;
    }

    return 1;
}


// lcd memory is packed as 6 bits per column.
// so we should unpack 240 / 8 = 30 bytes to 240 / 6 = 40 bytes.
// each 3 bytes are unpacked to 4 bytes
// sequence is: 0: byte[0] >> 2
//              1: byte[0] << 4 | byte[1] >> 4
//              2: byte[1] << 2 | byte[2] >> 6
//              3: byte[2]
bool HAL_lcd_render_graphic(const hal_lcd_graph_buf_t *buf)
{
    int gen_idx;
    int buf_idx;

    int graphic_sender(void)
    {
        if (gen_idx >= HAL_LCD_YSIZE * HAL_LCD_XSIZE / 6)
            return -1;

        int result;

        switch (gen_idx & 0x03)
        {
        case 0:
            result = buf->raw[buf_idx] >> 2;
            break;
        case 1:
            result = (buf->raw[buf_idx] << 4) | (buf->raw[buf_idx + 1] >> 4);
            break;
        case 2:
            result = (buf->raw[buf_idx + 1] << 2) | (buf->raw[buf_idx + 2] >> 6);
            break;
        case 3:
            result = buf->raw[buf_idx + 2];
            buf_idx += 3;
            break;
        }
        gen_idx++;
        return result & 0x3F;
    }

    gen_idx = 0;
    buf_idx = 0;

    LCD_XFER
    {
        write_mem_from_generator(GRAPHIC_PAGE_ADDR, graphic_sender);

        rt.flags |= F_LCD_IS_GRAPHIC;
        rt.flags |= F_LCD_IS_ON;
        if (! update_display_mode())
            return 0;
    }

    return 1;
}



bool HAL_lcd_position_cursor(uint col, uint row, uint size, bool is_blinking)
{
    REQUIRE(col < HAL_LCD_NCOLS && row < HAL_LCD_NROWS && size <= 8);

    uint data = (row << 8) | col;

    LCD_XFER
    {
        if (! exec_cmd(SET_CURSOR_POINTER, &data, 2))
            return 0;

        if (size)
            rt.flags |= F_LCD_CURSOR_IS_DISPLAYED;
        else
            rt.flags &= ~F_LCD_CURSOR_IS_DISPLAYED;

        if (is_blinking)
            rt.flags |= F_LCD_CURSOR_IS_BLINKING;
        else
            rt.flags &= ~F_LCD_CURSOR_IS_BLINKING;


        if (size)
        {
            if (! exec_cmd(SET_CURSOR_SIZE_PREFIX | (size - 1), NULL, 0))
                return 0;
        }

        if (! update_display_mode())
            return 0;
    }

    return 1;
}


void HAL_lcd_init(void)
{
    ctrlport->BSRR = (1 << wr_pin_idx) | (1 << rd_pin_idx) | (1 << cd_pin_idx) | (1 << ce_pin_idx);
    hal_pincfg_out(ctrlport, wr_pin_idx);
    hal_pincfg_out(ctrlport, rd_pin_idx);
    hal_pincfg_out(ctrlport, ce_pin_idx);
    hal_pincfg_out(ctrlport, cd_pin_idx);

    dataport->BRR =   (1 << data0_pin_idx) | (1 << data1_pin_idx) | (1 << data2_pin_idx) | (1 << data3_pin_idx)
                    | (1 << data4_pin_idx) | (1 << data5_pin_idx) | (1 << data6_pin_idx) | (1 << data7_pin_idx);

    switch_to_output();

    for (uint i = CONFIGURE_ATTEMPTS; i; i--)
    {
        if (configure())
            return;
        WARN("failed to configure lcd. trying again");
    }
    ERR("failed to configure lcd. giving up");
    REQUIRE(0);
}

#if 0

#include "testpic.h"

void HAL_lcd_smoke(void)
{
    HAL_lcd_init();

    HAL_lcd_render_graphic(testpic);

    HAL_systimer_sleep(1000);

    hal_lcd_text_buf_t buf;
    memset(&buf, 0, sizeof(buf));
    for (uint i = 0; i < countof(buf.raw); i++)
    {
        buf.raw[i] = i;
    }

    HAL_lcd_render_ugly_encoded_text(&buf);

//  HAL_systimer_sleep(1000);
//
//  HAL_lcd_render_text(&buf);
//
//  HAL_lcd_position_cursor(3, 4, 1, 1);
//  HAL_systimer_sleep(1000);
//  HAL_lcd_position_cursor(5, 6, 8, 0);

    while (1);
    {
    }
}
#endif
