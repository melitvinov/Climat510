#define _HAL_LCD_C_

#include "syntax.h"

#include "stm32f10x.h"

#include "hal_pincfg.h"
#include "hal_lcd.h"

#include "debug.h"

static GPIO_TypeDef *const dataport = GPIOB;
static GPIO_TypeDef *const ctrlport = GPIOC;

static const uint data0_pin_idx = 2;
static const uint data1_pin_idx = 3;
static const uint data2_pin_idx = 4;
static const uint data3_pin_idx = 5;

static const uint data4_pin_idx = 12;
static const uint data5_pin_idx = 13;
static const uint data6_pin_idx = 14;
static const uint data7_pin_idx = 15;

static const uint wr_pin_idx = 6;
static const uint rd_pin_idx = 7;
static const uint ce_pin_idx = 8;
static const uint cd_pin_idx = 9;

// NOTE: default pin state is: command, no chip enable, no read, no write, databus is output

static inline int assert_ce(void)               { ctrlport->BRR = (1 << ce_pin_idx); return 1;}
static inline void deassert_ce(int *dummy)      { ctrlport->BSRR = (1 << ce_pin_idx); }

static inline void assert_wr(void)              { ctrlport->BRR = 1 << wr_pin_idx;}
static inline void deassert_wr(void)            { ctrlport->BSRR = 1 << wr_pin_idx;}
static inline void assert_rd(void)              { ctrlport->BRR = 1 << rd_pin_idx;}
static inline void deassert_rd(void)            { ctrlport->BSRR = 1 << rd_pin_idx;}
static inline void assert_data_mode(void)       { ctrlport->BRR = 1 << cd_pin_idx;}
static inline void deassert_data_mode(void)     { ctrlport->BSRR = 1 << cd_pin_idx;}

#define LCD_XFER for (int _todo __cleanup(deassert_ce) = assert_ce(); _todo; _todo = 0)

static inline void wait_50ns(void)
{
    __NOP();
    __NOP();
}

// high-z
static void switch_to_input(void)
{
    dataport->CRL = (dataport->CRL & 0xFF0000FF) | 0x00444400;
    dataport->CRH = (dataport->CRH & 0x0000FFFF) | 0x44440000;
}

// push-pull, 50 MHz
static void switch_to_output(void)
{
    dataport->CRL = (dataport->CRL & 0xFF0000FF) | 0x00333300;
    dataport->CRH = (dataport->CRH & 0x0000FFFF) | 0x33330000;
}

// generated by http://programming.sirrida.de/calcperm.php
static void drive_data(uint data)
{
    uint to_set = data;
    uint to_clear = ~data;

    dataport->BSRR =   ((to_set & 0x0F) << 2) | ((to_set & 0xF0) << 8)
                     | ((to_clear & 0x0F) << 18) | ((to_clear & 0xF0) << 24);
}

static uint sample_data(void)
{
    uint reg = dataport->IDR;
    return ((reg & 0x0000F000) >> 8) | ((reg & 0x0000003C) >> 2);
}

// keep it simple for now
static void write_cmd(uint cmd)
{
    drive_data(cmd);

    assert_wr();
    wait_50ns();
    wait_50ns();
    deassert_wr();
    wait_50ns();
}

static void write_data(uint data)
{
    drive_data(data);

    assert_data_mode();
    wait_50ns();
    assert_wr();
    wait_50ns();
    wait_50ns();
    deassert_wr();
    wait_50ns();
    deassert_data_mode();
}


static uint read_cmd(void)
{
    switch_to_input();

    assert_rd();
    wait_50ns();
    wait_50ns();
    wait_50ns();
    wait_50ns();
    uint result = sample_data();
    deassert_rd();
    wait_50ns();

    switch_to_output();
    return result;
}


static bool verify_status(uint val, uint mask)
{
    bool is_ok = 0;

    switch_to_input();

    assert_rd();
    wait_50ns();
    wait_50ns();
    wait_50ns();

    uint tries = STATUS_CHECK_N_TRIES;
    while (tries--)
    {
        uint result = sample_data();
        if ((result & mask) == val)
        {
            is_ok = 1;
            break;
        }
    }

    //LOG("tries remain = %d",  tries);
    deassert_rd();
    wait_50ns();

    switch_to_output();
    return is_ok;
}



static bool exec_cmd(uint cmd, const void *data, uint len)
{
    const u8 *p = data;
    for (; len; len--)
    {
        if (! verify_status(3, 3))
            return 0;
        write_data(*p++);
    }

    if (! verify_status(3, 3))
        return 0;

    write_cmd(cmd);
    return 1;
}


static uint read_data(void)
{
    switch_to_input();

    assert_data_mode();
    wait_50ns();
    assert_rd();
    wait_50ns();
    wait_50ns();
    wait_50ns();
    uint result = sample_data();
    deassert_rd();
    wait_50ns();
    deassert_data_mode();
    switch_to_output();
    return result;
}


static bool write_mem(uint addr, const void *data, uint len)
{
    if (! exec_cmd(SET_ADDRRESS_POINTER, &addr, 2))
        return 0;

    if (! exec_cmd(SET_DATA_AUTO_WRITE, NULL, 0))
        return 0;

    const u8 *p = data;
    while (len--)
    {
        if (! verify_status(8, 8))
            return 0;
        write_data(*p++);
    }

    if (! exec_cmd(AUTO_RESET, NULL, 0))
        return 0;

    return 1;
}


static bool write_mem_from_generator(uint addr, int (*gen)(void))
{
    if (! exec_cmd(SET_ADDRRESS_POINTER, &addr, 2))
        return 0;

    if (! exec_cmd(SET_DATA_AUTO_WRITE, NULL, 0))
        return 0;

    int val;
    while ((val = gen()) >= 0)
    {
        if (! verify_status(8, 8))
            return 0;
        write_data(val);
    }

    if (! exec_cmd(AUTO_RESET, NULL, 0))
        return 0;

    return 1;
}


static bool configure(void)
{
    LCD_XFER
    {
        if (! exec_cmd(SET_DISPLAY_MODE_PREFIX | F_DISPLAY_MODE_OFF, NULL, 0)) return 0;

        uint data;
        data = GRAPHIC_PAGE_ADDR;
        if (! exec_cmd(SET_GRAPHIC_HOME_ADDRESS, &data, 2)) return 0;

        data = TEXT_PAGE_ADDR;
        if (! exec_cmd(SET_TEXT_HOME_ADDRESS, &data, 2)) return 0;

        PANIC_IF(CG_BASE_ADDR % 0x800);
        data = CG_BASE_ADDR / 0x800;
        if (! exec_cmd(SET_OFFSET_REGISTER, &data, 2)) return 0;

        data = HAL_LCD_NCOLS;
        if (! exec_cmd(SET_GRAPHIC_AREA, &data, 2)) return 0;
        if (! exec_cmd(SET_TEXT_AREA, &data, 2)) return 0;
        if (! exec_cmd(SET_MODE_PREFIX | F_MODE_EXOR, NULL, 0)) return 0;

        int gen_idx;
        int ram_cleaner(void)
        {
            if (gen_idx++ < LCD_RAM_SIZE)
                return 0;
            return -1;
        }

        int cg_loader(void)
        {
            extern const uchar ExtCG[];
            if (gen_idx < 96 * 8)
                return ExtCG[gen_idx++] - 0x20;
            return -1;
        }

        gen_idx = 0;
        if (! write_mem_from_generator(0, ram_cleaner)) return 0;

        gen_idx = 0;
        if (! write_mem_from_generator(CG_BASE_ADDR + 128 * 8, cg_loader)) return 0;

        if (! exec_cmd(SET_DISPLAY_MODE_PREFIX | F_DISPLAY_MODE_TEXT_ON_GRAPHIC_OFF , NULL, 0)) return 0;
    }

    return 1;
}

void HAL_lcd_init(void)
{
    ctrlport->BSRR = (1 << wr_pin_idx) | (1 << rd_pin_idx) | (1 << cd_pin_idx) | (1 << ce_pin_idx);
    hal_pincfg_out(ctrlport, wr_pin_idx);
    hal_pincfg_out(ctrlport, rd_pin_idx);
    hal_pincfg_out(ctrlport, ce_pin_idx);
    hal_pincfg_out(ctrlport, cd_pin_idx);

    dataport->BRR =   (1 << data0_pin_idx) | (1 << data1_pin_idx) | (1 << data2_pin_idx) | (1 << data3_pin_idx)
                    | (1 << data4_pin_idx) | (1 << data5_pin_idx) | (1 << data6_pin_idx) | (1 << data7_pin_idx);

    switch_to_output();

    for (uint i = CONFIGURE_ATTEMPTS; i; i--)
    {
        if (configure())
            return;
        WARN("failed to configure lcd. trying again");
    }
    ERR("failed to configure lcd. giving up");
    REQUIRE(0);
}


void HAL_lcd_smoke(void)
{
    HAL_lcd_init();

    LCD_XFER
    {
        int gen_idx;
        int graphic_filler(void)
        {
            if (gen_idx++ < 40)
                return 0xFF;
            return -1;
        }

        gen_idx = 0;
        write_mem_from_generator(GRAPHIC_PAGE_ADDR, graphic_filler);

        const char *str = "\240\24112345678901234567890123456789012345678a";

        int len = strlen(str);

        int text_filler(void)
        {
            if (gen_idx < len)
                return str[gen_idx++] - 0x20;
            return -1;
        }

        gen_idx = 0;
        write_mem_from_generator(TEXT_PAGE_ADDR, text_filler);

//        exec_cmd(SET_DISPLAY_MODE_PREFIX | F_DISPLAY_MODE_TEXT_OFF_GRAPHIC_ON, NULL, 0);

//      while (1)
//      {
//          HAL_systimer_sleep(1000);
//          for (uint i = 0; i < LCD_SRAM_SIZE - 40 * 64; i += 40)
//          {
//              exec_cmd(SET_GRAPHIC_HOME_ADDRESS, &i, 2);
//              HAL_systimer_sleep(100);
//          }
//      }

        while (1)
        {
            HAL_systimer_sleep(1000);
            exec_cmd(SET_DISPLAY_MODE_PREFIX | F_DISPLAY_MODE_TEXT_ON_GRAPHIC_OFF, NULL, 0);
            HAL_systimer_sleep(1000);
            exec_cmd(SET_DISPLAY_MODE_PREFIX | F_DISPLAY_MODE_TEXT_ON_GRAPHIC_ON, NULL, 0);
            HAL_systimer_sleep(1000);
        }

    }
}
