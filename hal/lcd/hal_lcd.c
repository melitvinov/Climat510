#define _HAL_LCD_C_

#include "syntax.h"

#include "stm32f10x.h"

#include "hal_pincfg.h"
#include "hal_lcd.h"
#include "lcd_font.h"


#include "debug.h"

static GPIO_TypeDef *const dataport = GPIOB;
static GPIO_TypeDef *const ctrlport = GPIOC;

static const uint data0_pin_idx = 2;
static const uint data1_pin_idx = 3;
static const uint data2_pin_idx = 4;
static const uint data3_pin_idx = 5;

static const uint data4_pin_idx = 12;
static const uint data5_pin_idx = 13;
static const uint data6_pin_idx = 14;
static const uint data7_pin_idx = 15;

static const uint wr_pin_idx = 6;
static const uint rd_pin_idx = 7;
static const uint ce_pin_idx = 8;
static const uint cd_pin_idx = 9;

static ldc_rt_t rt;

// NOTE: default pin state is: command, no chip enable, no read, no write, databus is output
static inline int assert_ce(void)               { ctrlport->BRR = (1 << ce_pin_idx); return 1;}
static inline void deassert_ce(int *dummy)      { ctrlport->BSRR = (1 << ce_pin_idx); }

static inline void assert_wr(void)              { ctrlport->BRR = 1 << wr_pin_idx;}
static inline void deassert_wr(void)            { ctrlport->BSRR = 1 << wr_pin_idx;}
static inline void assert_rd(void)              { ctrlport->BRR = 1 << rd_pin_idx;}
static inline void deassert_rd(void)            { ctrlport->BSRR = 1 << rd_pin_idx;}
static inline void assert_data_mode(void)       { ctrlport->BRR = 1 << cd_pin_idx;}
static inline void deassert_data_mode(void)     { ctrlport->BSRR = 1 << cd_pin_idx;}

#define LCD_XFER for (int _todo __cleanup(deassert_ce) = assert_ce(); _todo; _todo = 0)

static inline void wait_50ns(void)
{
    __NOP();
    __NOP();
}

// high-z
static void switch_to_input(void)
{
    dataport->CRL = (dataport->CRL & 0xFF0000FF) | 0x00444400;
    dataport->CRH = (dataport->CRH & 0x0000FFFF) | 0x44440000;
}

// push-pull, 50 MHz
static void switch_to_output(void)
{
    dataport->CRL = (dataport->CRL & 0xFF0000FF) | 0x00333300;
    dataport->CRH = (dataport->CRH & 0x0000FFFF) | 0x33330000;
}

// generated by http://programming.sirrida.de/calcperm.php
static void drive_data(uint data)
{
    uint to_set = data;
    uint to_clear = ~data;

    dataport->BSRR =   ((to_set & 0x0F) << 2) | ((to_set & 0xF0) << 8)
                     | ((to_clear & 0x0F) << 18) | ((to_clear & 0xF0) << 24);
}

static uint sample_data(void)
{
    uint reg = dataport->IDR;
    return ((reg & 0x0000F000) >> 8) | ((reg & 0x0000003C) >> 2);
}

// keep it simple for now
static void write_cmd(uint cmd)
{
    drive_data(cmd);

    assert_wr();
    wait_50ns();
    wait_50ns();
    deassert_wr();
    wait_50ns();
}

static void write_data(uint data)
{
    drive_data(data);

    assert_data_mode();
    wait_50ns();
    assert_wr();
    wait_50ns();
    wait_50ns();
    deassert_wr();
    wait_50ns();
    deassert_data_mode();
}


static bool verify_status(uint val, uint mask)
{
    bool is_ok = 0;

    switch_to_input();

    assert_rd();
    wait_50ns();
    wait_50ns();
    wait_50ns();

    uint result;
    uint tries = STATUS_CHECK_N_TRIES;
    do
    {
        result = sample_data();
        if ((result & mask) == val)
        {
            is_ok = 1;
            break;
        }
    } while (--tries);

    deassert_rd();
    wait_50ns();

    switch_to_output();

    if (! is_ok)
        WARN("failed to verify lcd status %d %d %d", result,  val, mask);

    return is_ok;
}



static bool exec_cmd(uint cmd, const void *data, uint len)
{
    const u8 *p = data;
    for (; len; len--)
    {
        if (! verify_status(3, 3))
            return 0;
        write_data(*p++);
    }

    if (! verify_status(3, 3))
        return 0;

    write_cmd(cmd);
    return 1;
}


static bool write_mem(uint addr, const void *data, uint len)
{
    if (! exec_cmd(SET_ADDRRESS_POINTER, &addr, 2))
        return 0;

    if (! exec_cmd(SET_DATA_AUTO_WRITE, NULL, 0))
        return 0;

    const u8 *p = data;
    while (len--)
    {
        if (! verify_status(8, 8))
            return 0;
        write_data(*p++);
    }

    if (! exec_cmd(AUTO_RESET, NULL, 0))
        return 0;

    return 1;
}


static bool write_mem_from_generator(uint addr, int (*gen)(void))
{
    if (! exec_cmd(SET_ADDRRESS_POINTER, &addr, 2))
        return 0;

    if (! exec_cmd(SET_DATA_AUTO_WRITE, NULL, 0))
        return 0;

    int val;
    while ((val = gen()) >= 0)
    {
        if (! verify_status(8, 8))
            return 0;
        write_data(val);
    }

    if (! exec_cmd(AUTO_RESET, NULL, 0))
        return 0;

    return 1;
}


static bool update_display_mode(void)
{
    uint mode;
    if (! (rt.flags & F_LCD_IS_ON))
    {
        mode = F_DISPLAY_MODE_OFF;
    }
    else
    {
        if (rt.flags & F_LCD_IS_GRAPHIC)
        {
            mode = F_DISPLAY_MODE_TEXT_OFF_GRAPHIC_ON;
        }
        else
        {
            mode = F_DISPLAY_MODE_TEXT_ON_GRAPHIC_OFF;
            if (rt.flags & F_LCD_CURSOR_IS_DISPLAYED)
            {
                if (rt.flags & F_LCD_CURSOR_IS_BLINKING)
                    mode |= F_DISPLAY_MODE_CURSOR_ON_BLINK_ON;
                else
                    mode |= F_DISPLAY_MODE_CURSOR_ON_BLINK_OFF;
            }

        }
    }

    if (! exec_cmd(SET_DISPLAY_MODE_PREFIX | mode, NULL, 0))
        return 0;

    return 1;
}


static bool configure(void)
{
    rt.flags &= ~F_LCD_IS_ON;

    LCD_XFER
    {
        if (! update_display_mode())
            return 0;

        uint data;
        data = GRAPHIC_PAGE_ADDR;
        if (! exec_cmd(SET_GRAPHIC_HOME_ADDRESS, &data, 2)) return 0;

        data = TEXT_PAGE_ADDR;
        if (! exec_cmd(SET_TEXT_HOME_ADDRESS, &data, 2)) return 0;

        PANIC_IF(CG_BASE_ADDR % 0x800);
        data = CG_BASE_ADDR / 0x800;
        if (! exec_cmd(SET_OFFSET_REGISTER, &data, 2)) return 0;

        data = HAL_LCD_NCOLS;
        if (! exec_cmd(SET_GRAPHIC_AREA, &data, 2)) return 0;
        if (! exec_cmd(SET_TEXT_AREA, &data, 2)) return 0;

        if (! exec_cmd(SET_MODE_PREFIX | F_MODE_EXOR | F_MODE_EXT_CG, NULL, 0)) return 0;

        uint gen_idx;
        int ram_cleaner(void)
        {
            if (gen_idx++ < LCD_RAM_SIZE)
                return 0;
            return -1;
        }

        int cg_loader(void)
        {
            if (gen_idx < sizeof(lcd_font))
                return (lcd_font[gen_idx++]);
            return -1;
        }

        gen_idx = 0;
        if (! write_mem_from_generator(0, ram_cleaner)) return 0;

        gen_idx = 0;
        if (! write_mem_from_generator(CG_BASE_ADDR, cg_loader)) return 0;
    }

    return 1;
}


// TODO: add some rollback in case of errors ? Now we just fail
bool HAL_lcd_render_text(const hal_lcd_text_buf_t *buf)
{
    LCD_XFER
    {
        if (! write_mem(TEXT_PAGE_ADDR, buf->raw, sizeof(buf->raw)))
            return 0;

        rt.flags &= ~F_LCD_IS_GRAPHIC;
        rt.flags |= F_LCD_IS_ON;
        if (! update_display_mode())
            return 0;
    }

    return 1;
}


// lcd memory is packed as 6 bits per column.
// so we should unpack 240 / 8 = 30 bytes to 240 / 6 = 40 bytes.
// each 3 bytes are unpacked to 4 bytes
// sequence is: 0: byte[0] >> 2
//              1: byte[0] << 4 | byte[1] >> 4
//              2: byte[1] << 2 | byte[2] >> 6
//              3: byte[2]
bool HAL_lcd_render_graphic(const hal_lcd_graph_buf_t *buf)
{
    int gen_idx;
    int buf_idx;

    int graphic_sender(void)
    {
        if (gen_idx >= HAL_LCD_YSIZE * HAL_LCD_XSIZE / 6)
            return -1;

        int result;

        switch (gen_idx & 0x03)
        {
        case 0:
            result = buf->raw[buf_idx] >> 2;
            break;
        case 1:
            result = (buf->raw[buf_idx] << 4) | (buf->raw[buf_idx + 1] >> 4);
            break;
        case 2:
            result = (buf->raw[buf_idx + 1] << 2) | (buf->raw[buf_idx + 2] >> 6);
            break;
        case 3:
            result = buf->raw[buf_idx + 2];
            buf_idx += 3;
            break;
        }
        gen_idx++;
        return result & 0x3F;
    }

    gen_idx = 0;
    buf_idx = 0;

    LCD_XFER
    {
        write_mem_from_generator(GRAPHIC_PAGE_ADDR, graphic_sender);

        rt.flags |= F_LCD_IS_GRAPHIC;
        rt.flags |= F_LCD_IS_ON;
        if (! update_display_mode())
            return 0;
    }

    return 1;
}



bool HAL_lcd_position_cursor(uint col, uint row, uint size, bool is_blinking)
{
    REQUIRE(col < HAL_LCD_NCOLS && row < HAL_LCD_NROWS && size <= 8);

    uint data = (row << 8) | col;

    LCD_XFER
    {
        if (! exec_cmd(SET_CURSOR_POINTER, &data, 2))
            return 0;

        if (size)
            rt.flags |= F_LCD_CURSOR_IS_DISPLAYED;
        else
            rt.flags &= ~F_LCD_CURSOR_IS_DISPLAYED;

        if (is_blinking)
            rt.flags |= F_LCD_CURSOR_IS_BLINKING;
        else
            rt.flags &= ~F_LCD_CURSOR_IS_BLINKING;


        if (size)
        {
            if (! exec_cmd(SET_CURSOR_SIZE_PREFIX | (size - 1), NULL, 0))
                return 0;
        }

        if (! update_display_mode())
            return 0;
    }

    return 1;
}


void HAL_lcd_init(void)
{
    ctrlport->BSRR = (1 << wr_pin_idx) | (1 << rd_pin_idx) | (1 << cd_pin_idx) | (1 << ce_pin_idx);
    hal_pincfg_out(ctrlport, wr_pin_idx);
    hal_pincfg_out(ctrlport, rd_pin_idx);
    hal_pincfg_out(ctrlport, ce_pin_idx);
    hal_pincfg_out(ctrlport, cd_pin_idx);

    dataport->BRR =   (1 << data0_pin_idx) | (1 << data1_pin_idx) | (1 << data2_pin_idx) | (1 << data3_pin_idx)
                    | (1 << data4_pin_idx) | (1 << data5_pin_idx) | (1 << data6_pin_idx) | (1 << data7_pin_idx);

    switch_to_output();

    for (uint i = CONFIGURE_ATTEMPTS; i; i--)
    {
        if (configure())
            return;
        WARN("failed to configure lcd. trying again");
    }
    ERR("failed to configure lcd. giving up");
    REQUIRE(0);
}


#if 0

#include "testpic.h"

void HAL_lcd_smoke(void)
{
    HAL_lcd_init();

    HAL_lcd_render_graphic(testpic);

    HAL_systimer_sleep(1000);

    hal_lcd_text_buf_t buf;
    memset(&buf, 0, sizeof(buf));
    for (uint i = 0; i < countof(buf.raw); i++)
        buf.raw[i] = i;

    HAL_lcd_render_text(&buf);

    HAL_lcd_position_cursor(3, 4, 1, 1);
    HAL_systimer_sleep(1000);
    HAL_lcd_position_cursor(5, 6, 8, 0);

    while (1);
    {
    }
}
#endif
